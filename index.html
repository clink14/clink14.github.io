<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Crystal Water Blob – Realistic Environment</title>
<style>
  html, body {margin:0;height:100%;overflow:hidden;background:#000;}
  canvas {width:100%;height:100%;display:block;}
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 1.2, 3);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.25;

// Lighting
const key = new THREE.PointLight(0xffffff, 12);
scene.add(key);
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

// Environment background + reflections
const loader = new THREE.TextureLoader();
let envTex = null;
loader.load(
  'https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg',
  tex => {
    tex.mapping = THREE.EquirectangularReflectionMapping;
    tex.encoding = THREE.sRGBEncoding;
    envTex = tex;
    scene.background = tex;    // ✅ now visible background
    scene.environment = tex;   // ✅ reflections use it too
  }
);

// Water blob geometry
const geo = new THREE.SphereGeometry(1, 256, 256);

// Shader material — water look with rainbow dispersion
const mat = new THREE.ShaderMaterial({
  uniforms: {
    time:      { value: 0 },
    envMap:    { value: null },
    cameraPos: { value: new THREE.Vector3() },
    ior:       { value: 1.333 },
    tint:      { value: new THREE.Color(0xf5fdff) },
    lightDir:  { value: new THREE.Vector3(0.4, 0.7, 0.2).normalize() }
  },
  vertexShader: `
    uniform float time;
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vec3 p = position;
      // soft, organic ripple motion
      p += normal * 0.035 * sin(p.y*6.0 + time*2.0 + p.x*3.0);
      p += normal * 0.025 * sin(p.x*7.0 - time*1.5 + p.z*2.5);
      p += normal * 0.020 * sin(p.z*8.0 + time*2.2 + p.y*3.0);
      vec4 worldPos = modelMatrix * vec4(p,1.0);
      vWorldPos = worldPos.xyz;
      vNormal   = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * viewMatrix * worldPos;
    }
  `,
  fragmentShader: `
    precision highp float;

    uniform sampler2D envMap;
    uniform vec3 cameraPos;
    uniform float time;
    uniform float ior;
    uniform vec3 tint;
    uniform vec3 lightDir;

    varying vec3 vWorldPos;
    varying vec3 vNormal;

    vec3 sampleEnv(vec3 dir){
      dir = normalize(dir);
      float u = atan(dir.z, dir.x) / (2.0 * 3.14159265) + 0.5;
      float v = dir.y * 0.5 + 0.5;
      return texture2D(envMap, vec2(u, v)).rgb;
    }

    void main(){
      vec3 N = normalize(vNormal);
      vec3 V = normalize(cameraPos - vWorldPos);

      // Gentle surface ripples
      vec3 noise = vec3(
        sin(vWorldPos.y*8.0 + time*2.0),
        sin(vWorldPos.z*9.0 - time*2.3),
        sin(vWorldPos.x*10.0 + time*2.6)
      );
      N = normalize(N + 0.05 * noise);

      // Dispersion (slightly different IOR per color)
      float iorR = 1.333;
      float iorG = 1.340;
      float iorB = 1.347;

      vec3 refrR = refract(-V, N, 1.0 / iorR);
      vec3 refrG = refract(-V, N, 1.0 / iorG);
      vec3 refrB = refract(-V, N, 1.0 / iorB);

      float facing = clamp(1.0 - max(dot(N, V), 0.0), 0.0, 1.0);
      float thickness = 0.4 + 1.6 * facing;

      vec3 absorptionCoeff = vec3(0.01, 0.03, 0.06);
      vec3 attenuation = exp(-absorptionCoeff * thickness);

      vec3 colR = sampleEnv(refrR);
      vec3 colG = sampleEnv(refrG);
      vec3 colB = sampleEnv(refrB);
      vec3 refrCol = vec3(colR.r, colG.g, colB.b);
      refrCol *= attenuation * tint;

      // Soft shadow imitation
      vec3 L = normalize(lightDir);
      float NdotL = max(dot(N, L), 0.0);
      float fakeShadow = 0.35 + 0.65 * NdotL;
      float backShadow = exp(-thickness * 1.5);
      float shadow = mix(backShadow, fakeShadow, NdotL);

      // Reflection
      float F0 = 0.02;
      float cosTheta = max(dot(N, V), 0.0);
      float fres = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
      vec3 reflDir = reflect(-V, N);
      vec3 reflCol = sampleEnv(reflDir);
      float reflStrength = fres * 0.035;
      vec3 color = mix(refrCol, reflCol, reflStrength);

      // Rainbow sparkle highlight
      vec3 H = normalize(L + V);
      float specAngle = max(dot(N, H), 0.0);
      float spec = pow(specAngle, 220.0);
      float viewShift = clamp(dot(V, N), 0.0, 1.0);
      vec3 rainbow = vec3(
        0.9 + 0.1 * sin(time*2.0  + viewShift*5.0),
        0.9 + 0.1 * sin(time*2.3  + viewShift*6.0),
        1.0
      );
      color += rainbow * spec * 0.22;

      // Edge glow
      color += tint * pow(facing, 3.0) * 0.08;

      color *= shadow;
      color = clamp(color, 0.0, 10.0);
      color = pow(color, vec3(0.4545));

      float alpha = 0.35 + 0.4 * pow(facing, 1.5);
      gl_FragColor = vec4(color, alpha);
    }
  `,
  transparent: true
});

const blob = new THREE.Mesh(geo, mat);
scene.add(blob);

// Animation
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  if(envTex) mat.uniforms.envMap.value = envTex;
  mat.uniforms.time.value = t;
  mat.uniforms.cameraPos.value.copy(camera.position);

  // subtle breathing motion
  const s = 1.0 + Math.sin(t*1.5)*0.02;
  blob.scale.set(s, s, s);

  // moving light
  const r = 3.0;
  key.position.set(Math.sin(t)*r, 1.5+Math.sin(t*0.7), Math.cos(t)*r);

  controls.update();
  renderer.render(scene, camera);
}

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>
</body>
</html>
